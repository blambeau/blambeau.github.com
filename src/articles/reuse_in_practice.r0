In a @{reuse}{previous post} I compared _Software Reuse_ techniques discussed in @?{Charles W. Krueger Software Reuse}{Krueger's 1992 paper} (_high level languages_, _source code components_, _software architectures_, _application generators_ and so on.) with the numerous languages, abstractions and tools that we use today. As we've seen, 

bq. For a reuse technique to be effective, it *minimizes the cognitive distance* (i.e. the intellectual effort required) between the initial concept of a system and its final executable implementation. Two kinds of intellectual efforts can be minimized in practice: 1) the one required to go *from the initial system conceptualization to a specification* in abstractions of the reuse technique and 2) the one required to *produce an executable system from the specification* produced.

The issued addressed here is: _What efforts are still required to achieve a more effective reuse in practice?_ And the topic will be addressed in the light of these simple yet sound foundations.

h3. Scope of the discussion

I intentionally restrict (with loss of generality) the scope of what _Software Reuse_ means here in comparison with @?{Charles W. Krueger Software Reuse}{Krueger's paper} and @{reuse}{my previous post} by considering _black-box reuse_ only. That is, I consider pieces of software that can be seen as mathematical functions: they compute an output from a well defined input:

p=. !@{images/reuse/io_reuse.gif}!

Making so certainly restricts the software reuse techniques covered by this post: _software architectures_ for example are grey-boxes and may not easily be seen as functions. The same applies to certain _source code components_ (reusable libraries), if they are *intentionally not designed* (remark the wording) to be used as pure black-box functions.