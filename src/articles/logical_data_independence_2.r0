My @{logical_data_independence}{first post about logical data independence} if the most read on this blog. So I bet that writing the next part would be appreciated. Let's start by summarizing the first paper:

!!{Data independence means *"avoiding changes made to the data module of a software to propagate and hurt its other parts"*.}

!!{*Physical data independence* is this concept applied to the database physical layer. This layer forms the internal specification of the database and is concerned with the following questions: where is data localized? in which encoding? are there indexes available? which kind? }

!!{*Logical data independence* is this concept applied to the database logical layer. This logical layer is part of the public, external specification of the database: what real-world concepts is the database talking about? how do they relate to each other? how can we query that data?}

h3. Two kinds of change

From the definitions, distinguishing physical from logical changes is easy: if you move your data from one place to another one, if you add an index, if you change the encoding, etc. you make a physical change. If your database offers physical data independence (which is the case with SQL databases in practice), you won't have to change too much code in your software, if any.

In contrast, if you add a concept (for example, a table or a column in SQL terms) or worse if you delete, rename, split or change a concept (typically a table here) you are making a logical change. If your database offers logical data independence (not so often in practice), you won't have to change too much code in your software, if any.

Note that most authors restrict their attention to physical and logical *schema changes*, which is only part of the corresponding layers. From the most general point of view we must also consider other kinds of change. For instance, modifying the semantics of the logical query language (SQL, for example) is a change to the logical layer. And a non-backward compatible change would certainly hurts logical independence.

h4. Aside: _What kind of database?_

I would like to stress the fact that I'm not exclusively talking about _relational databases_ here. Those independence concepts have been made clear thanks to Codd's job on the relational model but they are sufficiently abstract to be relevant to other kinds of databases. If you know about some of the NoSQL databases that recently appeared, I strongly invite you to apply critical thinking in terms of physical vs. logical layers and data independence. Note that I'm not especially advocating for or against them here (there would be a lot to say about this, but it is not my aim in this particular post). Nevertheless, if many NoSQL writings discuss scalability, consistency, availability and/or partition tolerance (also have a google search about what is called the @?{CAP theorem}) only a few so far propose a discussion in terms of these classical concepts which are equally important in my opinion.

h3. Examples of logical change

In contrast to physical independence, few books give convincing examples of changes applied to the logical layer. Moreover, none that I know gives any tip or pattern for preventing such changes to propagate and hurt the rest of the software code. This is very strange in a sense because logical changes are often a consequence of software success: new features and enhancement of existing ones will certainly require changes to the logical database schema.
