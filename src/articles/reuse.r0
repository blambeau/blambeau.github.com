With colleagues we have a somewhat recurrent discussion about _software reuse_. Discussion has raised once again recently, so I decided to summarize my personal point of view on this blog. After a short review of a good (yet already old) paper from the scientific literature, I would like to discuss the specific difficulties I've almost always encountered in my own work and my two-cents proposal to have more effective reuse in practice.

h3. A short review of a survey

The concept of _software reuse_ is not new and many writings already exist about it. Probably the better I've read so far is a review due to Charles W. Krueger published in 1992 and simply entitled _Software Reuse_[1]. The abstract starts with the following paragraph:

bq. Software reuse is the process of creating software systems from existing software rather than building software systems from scratch. This simple yet powerful vision was introduced in 1968 (ed. in [2]). Software reuse has, however, failed to become a standard software engineering practice. In an attempt to understand why, researchers have renewed their interest in software reuse and in the obstacles to implementing it. 

The paper is actually a survey of the research efforts at that time about _reuse techniques_. The techniques discussed are (I will briefly discuss each of them a bit later): 

bq. _high-level languages_, _design and code scavenging_, _source code components_, _software schemas_, _application generators_, _very high-level languages_, _transformational systems_ and _software architectures_.

Each technique is more fully described in the body of the paper (a section of 2 to 3 pages each). There, they are  classified along four main dimensions:

* *Abstraction*. What are the ``software abstractions'' introduced by the reuse technique? In other words what is the type of software artifacts that are reused and what abstractions describe them?
* *Selection*. How are the reusable artifacts intended to be selected for reuse? How to locate and compare them, for example?
* *Specialization*. Artifacts are generalizations. Reusing an artifact implies having a way to specialize it back (through parameters, constraints, ...). How is this achieved for each technique?
* *Integration*: How are reusable artifacts integrated inside the complete software system under construction? 

The paper also aims at _evaluating_ the effectiveness of the reuse techniques, or at least it gives clues to do so. For this it calls for gauging the effectiveness of a reuse technique in terms of _cognitive distance_, that is, in terms of the _intellectual effort required (by software developers) to use it_. Interestingly, the author points out in his conclusion that the cognitive distance can be reduced in two ways:

* by reducing the intellectual effort required to go *from the conceptualization of a system to a specification* in the abstractions proposed by the reuse technique and, 
* by reducing the effort required to *produce an executable system from that specification*.

The paper also provides an approximate ranking of the height reuse techniques, rated on how well they minimize cognitive distance by each of the two methods mentioned above. _Application generators_ win the first ranking while _high level languages_ win the second one (refer to the paper for details).

h4. A personal opinion

I'd like to close this section with something maybe more subjective. First, we can argue retrospectively about the effectiveness of the reuse techniques. The same certainly applies about the paper rankings. My personal feeling however is that the rankings are quite convincing even if not all reuse techniques suffer the same success. Second, I would like to point out how relevant the _research method_ seems to me (don't forget that the paper has been published in 1992): 

* most of the reusable artifacts and reuse techniques I know and use everyday are covered by this survey, 
* in my opinion, the four dimensions chosen for classifying them still give remarkable clues today for comparing and improving the tools we have,
* when evaluating the effort required to apply a reuse technique, the notion of _cognitive distance_ and the relevance of distinguishing between ease of specification (in terms of reusable abstractions) and ease of realization (i.e. obtaining an executable) is definitely worth considering ... and should be considered much more often, IMHO (at the risk of making a forward reference: your technique/language/library/whatever is only effective if it helps gaining both ways, or at least if gaining one way is not at the expense of the other).

Of course, I'll specifically refer to these points later in this post. Before actually discussing the specific difficulties I encounter in practice, I would like to review the different reuse techniques discussed in the paper in the light of the languages and tools we use in 2011.

h3. Quick overview of Reuse Techniques

Nowadays, no one would seriously argue that _software reuse has failed to become a standard software engineering practice_. Let have a quick look at each of the technique mentioned in the paper, in the light of the tools we have today. Note that I've tried to be consistent with the paper, in terms of the software abstractions behind each reuse technique. Some of the terms used in the paper may have a slightly different meaning today. Also note that the different techniques may overlap, as already implicitly pointed by Krueger himself.

h4. High Level Languages

*{info.programming_languages as l}{"_!{l}_":http://lmgtfy.com/?q=!{l}+programming+language}{, } and so on., high level languages are numerous and various. Each one comes with its set of tools to raise the abstraction level (sometimes in certain respects only, like providing good abstractions for concurrency, or low-level tasks).

h4. Source code components

High level languages also come with effective abstractions to build and share "abstract data types" and other "reusable libraries". Source code components are generally intended to be used as black-boxes: a public interface of usage is announced, formally or not (ruby has not equivalent of java interfaces, for example), while the realization of this interface is kept hidden (or at least intended to be). Think to C libraries, java's .jars, python's modules, ruby's gems, and so on. In many languages, "find a component, download it, and go" has become a reality!

h4. Software architectures

Software architectures are large-grain software frameworks. In contrast to source code components, which are often black-boxes, software architecture are designed as grey-boxes: they are intended to be extended and provide specific extension points for this. We have a lot of reusable frameworks nowadays. Probably the most common are _web frameworks_ ("Ruby on Rails":http://rubyonrails.org/, "django":http://www.djangoproject.com/, "ASP.net":http://www.asp.net/, ...), _integrated development environment_ (IDE, "Eclipse":http://www.eclipse.org/ is worth mentioning due to its architecture), _service oriented architectures_ (SOA), and so on.

h4. Design and code scavenging

Design and code scavenging is simply a form of "find, copy-paste, adapt". The well-known design patterns[3] provide an organized form of _design scavenging_, by providing _catalogues_ for applying such kind of reuse.  Even if invented in the context of the object-oriented programming, design patterns had a great impact far beyond that programming paradigm.

_Code scavenging_ is less organized as few such catalogues exists. Every day however, the web gives use better ways to apply such a reuse technique: "google code search":http://www.google.com/codesearch, "github's gist":https://gist.github.com/, "pastie":http://www.pastie.org/, and so on. I also remember having read an book about Eclipse[4] whose authors encouraged applying the "monkey see, monkey do":http://lmgtfy.com/?q=monkey+see,+monkey+do rule, that is, copy pasting code from other Eclipse plugins whose source code is available.

h4. Application generators

Integrated Development Environment come bundled with _application generators_ (wizards that you find in Eclipse and Visual Studio are worth mentionning). Parser generators are common tools as well. In note in passing that my @{noe}{recent post about Noe} is an example of software reuse, somewhere between "controlled _code scavenging_" and _application generators_.

h4. Very High Level Languages (VHLL)

The concept of _very high level languages_ (VHLL) is more difficult to capture precisely and may lead to software reuse that is very specific to specialized domains. However, I would say that the recent advent of Domain Specific Languages (DSLs) and good support for them in dynamic languages (ruby, python, clojure, ...) can seen as promoting and helping buinding VHLLs.

h4. Transformational systems 

...

h4. Software schemas 

I must confess not being familiar with software schemas. The paper is not that clear about the concept and a google search does not return relevant results nowadays. I would like to know if they have had an impact on current software engineering practices. So if someone knows something about, just let me know!

h3. References

fn1. Charles W. Krueger, "_Software Reuse_":http://lmgtfy.com/?q=Charles+W.+Krueger,+Software+Reuse, ACM Computing Surveys, Volume 24 Issue 2, June 1992

fn2. Peter Naur and Brian Randell, "_Software engineering: Report of a conference sponsored by the NATO Science Committee_":http://homepages.cs.ncl.ac.uk/brian.randell/NATO/nato1968.PDF, Garmisch, Germany: Scientific Affairs Division, NATO, October 1968

fn3. Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides, "Design Patterns: Elements of Reusable Object-Oriented Software":http://lmgtfy.com/?q=Design+Patterns:+Elements+of+Reusable+Object-Oriented+Software, Addison-Wesley, 1995. ISBN 0-201-63361-2

fn4. Erich Gamma and Kent Beck, "Contributing to Eclipse: Principles, Patterns, and Plug-Ins":http://lmgtfy.com/?q=Contributing+to+Eclipse:+Principles,+Patterns,+and+Plug-Ins, Addison-Wesley, October 2003. ISBN 0-321-20575-8