title{Release Time!}
subtitle{Open-sources libraries available}
date{2009/03/13 - 10:17}

= Release Time!

It is a long time from the last post here! I've reached a major milestone yesterday
so it's time to write about it. I've spend most of the last weeks developing and 
developing, and developing again. Not for the blog, not for my research (at least not
directly) but for having tools (and I hope _quality_ tools) because they are definitly
required to build big things on solid foundations. This post is an public announcement:
{these tools are available as open source librairies}[http://code.chefbe.net] (MIT 
licence).

It has always been hard for me to decide that it's release time: new code may present bugs, 
insufficient test coverage or documentation, experimental ideas or features (this code is 
written by researchers and our job is to experiment things: even if the code is considered 
stable, the ideas it implements can be really experimental). I've decided not to be too shy
and to release anyway. The code is there and it can be used, that's and important achievement.

I've chosen to release three Ruby libraries that are not too experimental and stable enough to
be shared. Here are they:

== WLang reference implementation

If you have read previous posts, you have already heard a bit about _wlang_. Instead of first
writing a lot about it, I've decide to spend time implementing a stable reference implementation.
Two versions are {available online}[http://code.chefbe.net]: a first stable version tagged 0.7.0 
and the trunk version on which we are still working with my brother.

It's hard to explain what _wlang_ exactly is but here is the rule: if you have to generate text
(html, code, plain text, documentation, templated mails, or whatever) by mixing data inside 
templates, wlang is for you! It has been designed carefully to be both simple to use, powerful 
and extensible. The API documentation of the reference implementation (in Ruby) can be browsed
{here}[http://code.chefbe.net/docs/wlang/stable-0.7.0/api/index.html]. Probably more powerful,
the {reference card}[http://code.chefbe.net/docs/wlang/stable-0.7.0/api/SPECIFICATION.html] 
explains you everything you need to know.

We are still working actively on _wlang_ and plan to release a first 1.0 milestone release in
the next few weeks, with a lot of additional examples.

== Anagram

Long story of the previous years and weeks. I've always been bored by classical parser generators:
writing your grammar is often a nightmare. I've been introduced to 
{Parsing Expression Grammars}[http://en.wikipedia.org/wiki/Parsing_expression_grammar] (PEG) three 
years ago. In my opinion, PEG is much simpler and intuitive than other parsing techniques so I've
started a Java project a long time ago based on {Rats!}[http://cs.nyu.edu/rgrimm/xtc/rats.html].
This project was too experimental, not sufficiently tested nor documented and so it will never be 
released as a public library. 

Even if I use Ruby a lot today I'm of course facing the same needs as before (my research has'nt 
change because of a language shift). I was missing my PEG parsing tools in Ruby so I've started 
looking at people sharing this concern. {Treetop}[http://treetop.rubyforge.org] is PEG parser 
generator for Ruby that I recommend: first, it is PEG parsing; second, the language to write 
grammars is clean and simple; third, it is in Ruby, leading to powerful mechanisms around
your parser.

As you know, I'm a never happy guy: your parser generates a purely syntactic tree (each space, 
parenthese, bracket, cariage return, comment, etc.) leads to a tree node. Nothing important in
Treetop's common thinking: you can embed ruby code in your grammar definition and ignore those nodes.
Personally, I don't like embedding code in my grammar: it makes it usable for Ruby only (otherwise 
it can be seen as a language-independent grammar definition). Moreover, you always need tools for the 
semantic phase: convert strings to another data types (integers, booleans, ...), make semantic
checks (no two variables with the same name), parse other files (include, require, import exist
in almost all languages), etc. At the end, you would like to use your tree to generate text
or code in a specific language, digesting objects, etc. Last but not least, this whole process
while involving somewhat big developments, is also a really small milestone from the point of 
view of the software to build (in other words, building semantical information from raw data is
rarely a high level or strategic goal in your development).

Anagram is born from the lack of supporting tools for these hard (and a bit boring) tasks. It 
comes with a parser generator (same grammar format as Treetop), AST abstractions and rewriting 
tools and can be used in conjunction with _wlang_ for generating code. The online version is 
still experimental but accurately depicts the picture: the code to generate a parser from your
grammar file has less than 200 lines of code, thanks to rewriting tools and _wlang_.

== Chefbe Ruby Utility Classes

Much more anecdotal, I've created a repository of utility classes that are useful in different
projects. This first version contains only one class (a powerful composite Interval implementation) 
that a research teammate would like to reuse (or be inspired by). Many other classes will be 
extracted from specific projects and put in this repository instead. The rule for this project is 
simple: classes are self-contained (no intra/extra dependencies at all), well tested and documented.
I will probably not create a gem for this project: pick up the classes you are interested in, copy
it in your own codebase but please keep the licence header.

Enjoy those libraries!
