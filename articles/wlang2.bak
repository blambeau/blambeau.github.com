title{WLang (Part II)}
subtitle{}
date{2009/01/18 - 17:40}

= Fear trivial solutions, please

This article builds on the >{previous one}[wlang] and shows why some solutions
to SQL injection attacks used nowadays are not good or, most often, introduce
another problems ... However, my aim here is not to criticize these solutions 
for the critiscism's pleasure but because it seems to me that that, too often, we
claim having built a solution that reveals not being the good one. Let me take an 
example: assume I plan to build an HTML templating engine that always applies 
entities encoding to injected values (in order to prevent XSS attacks), then it 
will be impossible to create a web page by composition: no composed part would be 
allowed to participate to the HTML tree. XSS attacks are prevented, but the price
to pay is huge... That's what I call a "trivial solution".

The criticism applied here MUST be applied to _wlang_: after having read the next 
parts (>{wlang3} and >{wlang4}), you're really welcome to try to break _wlang_'s 
security, robustness and/or features. Indeed, _wlang_ is a young solution that need 
external eyes to evolve ! 

== PHP <tt>magic_quotes</tt>

Probably one of the most famous trivial solution to the "SQL injection attacks"
has been introduced by PHP's <em>magic_quotes</em> configuration variables. When
turned on, they automatically perfom backquoting on any data coming from the user
(i.e. through GET/POST/Cookie gloab variables). <b>This solution does not make
sense !</b> Of course, it makes sense for data whose intent is to be injected inside 
SQL queries (not even with all database engines), but with the side-effect of 
also backquoting data when injected in the HTML page. <b>Backquoting in such a case 
does not prevent for XSS attacks and definitively introduces unexpected behaviors.</b>

== Prepared statements

You could also think that <em>prepared statements</em> provides a solution to  
SQL injection attacks (and you're perfectly right) but it also looks to me as a 
trivial solution due to a side effect. This side effect is more complicated to 
explain but I think it is essential, so I've decided to spend some time on it. 

I've got a big problem with prepared statements: they shortly introduce <b>strong
coupling</b>. What does it mean? Let me take an example and consider the following
prepared statement:

 SELECT * FROM buying WHERE buyerName=? AND year(buyingDate)=?
 
It simply computes the buying of a given buyer for a given year. Fantastic so far,
I can use it in Java like this:

 String buyerName = ...
 String buyingDate = ...
 Connection c = ...
 PreparedStatement st = c.prepareStatement(/* the prepared query here */)
 ResultSet rs = st.execute(new Object[]{buyerName, buyingDate})

SQL injection attacks are prevented because the prepared statement always takes
care of encoding values in a way that preserves the query structure. Maybe you
are happy with that, I'm not (I'm never happy, i've said!). The reason why is that
I don't like embedding SQL queries in my code. If I would like to change the name
of a table, I'd have to review all my code, looking for queries that use it and
refactoring all of them. Because we >{do not use SQL databases the way we should 
do}[sql_the_way_we_should] such changes arrive, quickly and often. 

A pragmatic solution to this problem is to keep all (parameterized) queries in a 
configuration file, or under constants of a static class, or by installing server-side
stored procedures (views may not often be parameterized) that is, using queries 
by names instead of by their code. For example, (it's not really beautiful code
here, but I only introduce this for the sake of the example) I could try the following:

 class Queries
   public static final String BUYING_BY_BUYER_AND_YEAR = "/* the same query */"
 end
  
 class Client
   public void doSomethingWithIt(String buyerName, String buyingDate) {
     PreparedStatement st = c.prepareStatement(Queries.BUYING_BY_BUYER_AND_YEAR)
     ResultSet rs = st.execute(new Object[]{buyerName, buyingDate})
     /* and do something */
   }
 end

The problem to me here relies in the fact that the order in which injected values
are provided does matter. Indeed, suppose that the query is rewritten as:

 SELECT * FROM buying WHERE year(buyingDate)=? AND buyerName=? 
 
It is semantically the same query, but the code is definitely broken: I need to
change <tt>new Object[]{buyerName, buyingDate}</tt> by <tt>new Object[]{buyingDate, buyerName}</tt>
in order to make the application working correctly. Theoretically we say that the
query definitions and the client's code using them as <b>strongly coupled</b>: the
one cannot evolve without changing the other. The reason is the introduction of 
an order of query parameters by prepared statements (the same is true for embedded 
procedures). From the point of view of the query definition, this order
does not matter. By using prepared statements, we have lost the independence 
between the way we write the query and users that use it! To me, losing independence 
is probably one the biggest error in computer science (ironically, I must add that 
E.F. Codd, the inventor of the relational model was precisely looking for data 
independence: allowing client code to be independent of the way data is represented 
inside the database). If you are not convinced by this argumentation, just wait: 
sooner of later you'll pay for it, I promise!  
 
== Back to _wlang_
Enough for trivial solutions, you are not even obliged to agree with me. After this
digression, the >{next article}[wlang3] will introduce the core of _wlang_, an 
abstract grammar allowing code generation that works, without falling into a 
trivial solution (I hope so, I must add). Moreover, _wlang_ keeps things simple
because it allows high-level shortcuts for common tasks in particular situations. 
For example, using _wlang_ our query is simply written as follows:

 SELECT * FROM buying WHERE buyerName='{buyerName}' AND year(buyingDate)='{buyingDate}'
 
The instantiation of this query by _wlang_ prevents SQL injection attacks and you
keep independence. Seems magic? it is not. Seems hardcoded? not either. To understand
why, you'll have to wait for the >{fourth part}[wlang4] on _wlang_ called "Building
on the foundations". For now, lets >{build the foundations}[wlang3].     
   