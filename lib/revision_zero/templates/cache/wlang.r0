<p>As I&#8217;ve said previously (in the <a href="topics0">abstract of this paper</a>), each time you write a simple html page (or a <span class="caps">SQL</span> query) manually, what you are actually doing is creating a (kind of) program, that will be interpreted by a brower (or by a database engine). If the page or the query is created by string concatenation what you are actually doing is generating code. Generating code is far from trivial: you have to respect a lot of good practices and conventions in order to build correct and secure programs.  If you known perfectly what we mean by <em>proper value encoding</em>, <em>query structure preserving</em>, <em>backquoting</em>, and the like as well as the dramatic consequences that can occur by not applying them rigorously, then you are ready for enjoying <em>wlang</em> in this domain. In this case, you are invited to read the <a href="wlang2">second part of this article</a>. For the others, below is a short introduction to the problem that <em>wlang</em> solves. We mainly focus on security problems here but <em>wlang</em> helps solving code generation problems in a broader sense.</p>
<h3>Hello World in <span class="caps">PHP</span></h3>
<p>First of all: you can try this example <a href="sandbox/helloworld.php">here</a>.</p>
<p>Assume you&#8217;ve written a <code>helloworld.php</code> that invites the user to enter his name and simply says hello when the form is submitted:</p>
<div class="highlight"><pre><span class="x">&lt;html&gt;</span>
<span class="x">  &lt;head&gt;&lt;title&gt;Hello world in PHP&lt;/title&gt;&lt;/head&gt;</span>
<span class="x">  &lt;body&gt;</span>
<span class="x">    &lt;h1&gt;Hello </span><span class="cp">&lt;?</span><span class="o">=</span> <span class="nv">$_POST</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="cp">?&gt;</span><span class="x">&lt;/h1&gt;</span>
<span class="x">    &lt;form action=&quot;helloworld.php&quot; method=&quot;POST&quot;&gt;</span>
<span class="x">      &lt;input type=&quot;text&quot; name=&quot;name&quot;/&gt;</span>
<span class="x">      &lt;input type=&quot;submit&quot; value=&quot;Submit&quot;/&gt;</span>
<span class="x">    &lt;/form&gt;</span>
<span class="x">  &lt;/body&gt;</span>
<span class="x">&lt;/html&gt;</span>
</pre></div>
<p>What does <span class="caps">PHP</span> when it executes (or interprets) such a page (which is commonly called a <em>server page</em>, and similar examples can be found in <span class="caps">JSP</span>, <span class="caps">ASP</span>, Ruby On Rails, etc.) ? In the example at hand, it replaces the whole block<b><code>&lt;?= $POST['name'] ?&gt;</code></b> by what the user has entered in the form under the field called &#8216;name&#8217; (which is the actual execution of the <span class="caps">PHP</span> code <b><code>$POST['name']</code></b>). The resulting page is then sent to the browser which interprets it and this interpretation leads to the rendering of the page on your display.</p>
<p>In fact, each time you submit the form, <span class="caps">PHP</span> generates a new page saying hello to the name you&#8217;ve entered; this page is a kind of program that must be interpreted by the browser for correct rendering. More generally, each time <span class="caps">PHP</span> creates a page in response to a request by inserting computed values (which come from a form, a database, a web service, etc.) inside plain text, it generates code&#8230;</p>
<table>
	<tr>
		<td><code>Question</code></td>
		<td>What is the intended behavior (or even, the specification) of the <span class="caps">HTML</span> page generated by <span class="caps">PHP</span> using the server page shown above?</td>
	</tr>
	<tr>
		<td><code>Response</code></td>
		<td>To display &#8217;Hello &#8217; followed by what the user has entered has name, as part of a <code>&lt;h1&gt;</code> tag.</td>
	</tr>
	<tr>
		<td><code>Try this</code></td>
		<td>put <code>&lt;script&gt;alert('You are a fu..... m..... f..... !!')&lt;/script&gt;</code> instead or your name in the form.</td>
	</tr>
	<tr>
		<td><code>Result?</code></td>
		<td>Your browser insults you and only <b>&#8217;Hello &#8217;</b> appears in the page.</td>
	</tr>
</table>
<p>If this behavior is not what is actually expected, we can say that the program  does not respect its specification. And the program we are talking about is the one <b>generated by <span class="caps">PHP</span></b>. Your server page is another program whose specification is <em>(with help of <span class="caps">PHP</span>), to generate programs which have as  specification to display Hello, &#8230;&#8217;</em>. Your server page does not either respect its specification, as it can generate programs that do not respect their own specification. As already said, generating code is far from trivial: a program that looks correct sometimes is not!</p>
<p>You probably know the solution to the problem here: enclosing <b><code>$_POST['name']</code></b> in a <b><code>htmlentities</code></b> function call. What is true here, is also true for 95% of the inclusions of that kind: <b>each time you inject non trustworthy values</b> inside a dynamically generated <span class="caps">HTML</span> page, <b>you have to invoke an entities encoder</b> unless you authorize the injection to change the structure of the page itself (that is, the injected value itself contains real tags of the generated page).</p>
<p>Forgetting to encode data properly like in the example leads to the well known <span class="caps">XSS</span> attack (<span class="caps">XSS</span> stands for Cross-Side Scripting) which can have much more dramatic consequences than insulting you (or worse, your client). Using a templating engine is not enough: few of them perform automatic encoding and those who do often fall into the kind of trivial solutions which will be described later. Moreover, let me insist on one fact: <b>it is not a problem specific to <span class="caps">PHP</span> and you can introduce security holes of this kind with almost all of the best web frameworks; also, <span class="caps">AJAX</span>-based technologies do not solve the problem!</b></p>
<table>
	<tr>
		<td><code>Conclusion</code></td>
		<td>As encoding is left to their responsibility, dramatic consequences of such attacks are due to developer&#8217;s errors. At least, it seems to be the conclusion of the recent <a href="http://www.sans.org/top25errors/">Experts Announce Agreement on the 25 Most Dangerous Programming Errors</a>.</td>
	</tr>
</table>
<h3>When SQL&#8217;s <em>select</em> performs a <em>delete</em></h3>
<p>First of all: if you want to learn more, read the <a href="http://en.wikipedia.org/wiki/SQL_injection">Wikipedia entry on <span class="caps">SQL</span> injection attacks</a>.</p>
<p>Assume this time that your application allows a user to display the list of its recent buying. For this, many developers build <span class="caps">SQL</span> queries by string concatenations. The <span class="caps">JAVA</span> code excerpt below provides a typical example:</p>
<div class="highlight"><pre><span class="n">String</span> <span class="n">buyerName</span> <span class="o">=</span> <span class="o">...</span>                  <span class="c1">// some buyer name received previously</span>
<span class="n">Connection</span> <span class="n">c</span> <span class="o">=</span> <span class="o">...</span>                      <span class="c1">// get a JDBC connection</span>
<span class="n">String</span> <span class="n">sql</span> <span class="o">=</span> <span class="s">&quot;SELECT * FROM buying &quot;</span> <span class="o">+</span>
             <span class="s">&quot;WHERE buyerName = &quot;</span> <span class="o">+</span> 
             <span class="s">&quot;&#39;&quot;</span> <span class="o">+</span> <span class="n">buyerName</span> <span class="o">+</span> <span class="s">&quot;&#39;&quot;</span>
<span class="n">Statement</span> <span class="n">st</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="na">createStatement</span><span class="o">(</span><span class="n">sql</span><span class="o">)</span>   <span class="c1">// create a query statement</span>
<span class="n">ResultSet</span> <span class="n">rs</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="na">execute</span><span class="o">()</span>             <span class="c1">// execute it and get result</span>
<span class="o">...</span>                                     <span class="c1">// display results to the user</span>
</pre></div>

<p>As previously, this program must be considered incorrect. If my name is O&#8217;Neil for example, it fails with a SQLException. Indeed, the created query will be the one below, which is not syntactically valid: the quote between O and Neil disturbs the query parser of the database engine, which raises an error.</p>
<div class="highlight"><pre><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">buying</span> <span class="k">WHERE</span> <span class="n">buyerName</span> <span class="o">=</span> <span class="s1">&#39;O&#39;</span><span class="n">Neil</span><span class="err">&#39;</span>
</pre></div>
<p>Assume now that I&#8217;ve got write access to the <em>buyerName</em> variable, that is, that I can choose its value (because it comes from a <span class="caps">GUI</span> or an <span class="caps">HTML</span> form, it is shown as a parameter in the query string of a web application, &#8230;). More dangerous than before, nothing prevents me to choose a value like &#8230; this:</p>
<div class="highlight"><pre><span class="s1">&#39;; DELETE FROM buying WHERE buyerName=&#39;</span><span class="n">concurrent</span>
</pre></div>
<p>and the result will be to execute the following query, with the obvious dramatic consequences.</p>
<div class="highlight"><pre><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">buying</span> <span class="k">WHERE</span> <span class="n">buyerName</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">;</span> 
<span class="k">DELETE</span> <span class="k">FROM</span> <span class="n">buying</span> <span class="k">WHERE</span> <span class="n">buyerName</span><span class="o">=</span><span class="s1">&#39;concurrent&#39;</span>
</pre></div>
<p>What is this to say? That building a query be concatenation of strings is generating code (here, it will be executed by a database engine). And, once again, that writing a program that generates correct and secure code is not an easy task: a program that looks correct sometimes is not!</p>
<p>You probably know the solution to this problem as well. There&#8217;s two solutions in fact. The first way consists in invoking some utility functions to encode values coming from the user before injecting them between quotes in a <span class="caps">SQL</span> query. The kind of encoding may depend on the database engine, and for example takes care of backslashing quotes (what is called <em>backquoting</em>). O&#8217;Neil, will become O\&#8217;Neil and the backslashed quote will not disturb the query parser at all! The same is true for the second example: the first quote of my dangerous value will be backslashed, not allowing me to inject real <span class="caps">SQL</span> code as previously.</p>
<p>The second way is probably considered as the best practice, and consists in creating what is called <em>prepared statements</em>, as in the following example:</p>
<div class="highlight"><pre><span class="n">String</span> <span class="n">buyerName</span> <span class="o">=</span> <span class="o">...</span>         
<span class="n">Connection</span> <span class="n">c</span> <span class="o">=</span> <span class="o">...</span>             
<span class="n">String</span> <span class="n">sql</span> <span class="o">=</span> <span class="s">&quot;SELECT * FROM buying WHERE buyerName = ?&quot;</span>
<span class="n">PreparedStatement</span> <span class="n">st</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="na">prepareStatement</span><span class="o">(</span><span class="n">sql</span><span class="o">)</span>
<span class="n">st</span><span class="o">.</span><span class="na">setString</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">buyerName</span><span class="o">);</span>
<span class="n">ResultSet</span> <span class="n">rs</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="na">execute</span><span class="o">()</span>
</pre></div>
<p>Creating queries this way also solves the problem: question mark are replaced by values at query execution time; this replacement may be seen as taking care of encoding values properly, based on their type (so that Strings will be first backquoted and then enclosed inside single quotes, for example).</p>
<p>Forgetting to encode data properly when creating <span class="caps">SQL</span> queries by string concatenation leads to the well known security attacks called &#8220;<span class="caps">SQL</span> injection attacks&#8221; Moreover, let me insist on one fact: <b>it is not a problem specific to Java and you can introduce  security holes of this kind with almost all of the best languages.</b> For example, in Ruby, the (much more developer-friendly) string below suffers the same kind of problem (Ruby automatically replaces the <code>#{buyerName}</code> part of this string by the invocation of <code>buyerName.to_s</code>):</p>
<div class="highlight"><pre><span class="n">buyerName</span> <span class="o">=</span> <span class="o">...</span>
<span class="n">sql</span> <span class="o">=</span> <span class="s">&quot;SELECT * FROM buying WHERE buyerName=&#39;#{buyerName}&#39;&quot;</span> 
</pre></div>
<table>
	<tr>
		<td><code>Conclusion?</code></td>
		<td>As backquoting is left to their responsibility, dramatic consequences of such attacks are due to developer&#8217;s errors. At least, it seems to be the conclusion of the recent <a href="http://www.sans.org/top25errors/">Experts Announce Agreement on the 25 Most Dangerous Programming Errors</a>.</td>
	</tr>
</table>
<h3>Where are we moving now?</h3>
<p>This first article about <em>wlang</em> were an introduction to the problem it solves. Even if we have mainly focussed on security problems, the problem is more general: building programs that generates code is an hard task. Indeed, each time you inject a value as part of the generated source <b>you have to respect the syntactical and semantical rules</b> that hold where the value is injected. Those rules are numerous and complex:</p>
<ol>
	<li>they depend on the target language (i.e. <span class="caps">HTML</span>, <span class="caps">SQL</span>, Java, Ruby, &#8230;)</li>
	<li>they may depend on a dialect: backquoting in MySQL vs. doublequoting in Sybase for example.</li>
	<li>they depend on the place where you inject the value: single-quoted strings vs. double-quoted strings for example.</li>
	<li>they depend on the injection semantics you want: does the injection participates to the <span class="caps">HTML</span> tree structure or not?</li>
	<li>they can change dynamically during generation: what if you generate an <span class="caps">HTML</span> page that also contains generated javascript or <span class="caps">CSS</span>? Or you could generate Ruby code that embed generated <span class="caps">SQL</span> queries, &#8230;</li>
</ol>
<p>I agree with the experts: developers make mistakes. But I also claim: there is a lack tool support for such tasks, even the simpler ones like generating an <span class="caps">HTML</span> page &#8230; WLang is an attempt to provide such a tool support: it is sufficiently abstract to have implementations in different languages, and sufficiently powerful to provide a robust and elegant solution (at least, I hope so!). The <a href="wlang2">second part</a> of this paper introduces its foundations, the <a href="wlang3">third one</a> builds on these foundations and shows how a powerful <span class="caps">HTML</span> templating engine can be created using wlang.</p>