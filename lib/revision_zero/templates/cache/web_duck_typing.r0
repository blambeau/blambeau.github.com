<p>This revision, of course, talks about the development of revision-zero.org itself: I can&#8217;t imagine maintaining my computer science blog by writing <span class="caps">HTML</span> files by hand! Everyone here knows that it would quickly lead to a nightmare: changing the template for example would require changing all articles that I&#8217;ve already written, maintaining page links would be difficult as well (my articles are numbered html files: <tt>0.html, 1.html, &#8230;</tt>, one for each revision).</p>
<p>However, I don&#8217;t want to use a web framework! Not because there are no good ones (there&#8217;s a lot, in fact), but it sounds to me like &#8220;killing a fly with a cannon&#8221; (typical Belgian expression, don&#8217;t know if it exists in English). So, I&#8217;ve decided to implement something myself: I keep my static files as the main architectural component and will try to reach an objective: this blog will walk like a dynamic site, it will quack like a dynamic site, I will call it a dynamic site, but it will mostly remain a static web site!</p>
<p>In particular this article is not written in <span class="caps">HTML</span> (that&#8217;s already a good achievement) and it only took four hours to get that&#8230; Below is an explanation of my solution Before that, let me introduce the topic. I&#8217;m a newcomer to the Ruby programming language: I&#8217;m using it for only three weeks. On the <a href="http://www.ruby-lang.org/en/community/mailing-lists">ruby-talk mailing list</a> last, week, someone asked the question &#8220;How Ruby?&#8221; (that is to say, &#8220;Can I master the language?&#8221;). Of course, I did not post a response to the question (I&#8217;m not a Ruby expert, not yet!) but I&#8217;ve got my own tricks to learn a new language. And my current objective (Web Duck Typing) provides a good example: I choose a project which is probably too hard for me, and I read other&#8217;s code. So, let&#8217;s turn to the solution now:</p>
<h3>From plain text to <span class="caps">HTML</span></h3>
<p>A great command-line tool coming with the Ruby distribution is <a href="http://rdoc.sourceforge.net/">rdoc</a>, which allows you to generate a javadoc-like documentation for your implementation projects. In particular, it can generate an html version of the <span class="caps">README</span>, <span class="caps">INSTALL</span>, <span class="caps">CHANGELOG</span>, etc. files. Moreover, those files are written in plain text: this is similar to the feature I&#8217;m looking for this blog. My plan is simple: I write my articles in the <em>rdoc</em> format (see below) and will use <em>rdoc</em> itself to generate my static files.</p>
<p>Unfortunately, thinks get more complicated when you invoke the <em>rdoc</em> command on a single file: it generates a whole documentation folder and expects your file to be part of a Ruby implementation project, which is not my case. Of course, I could try to learn how to write a specific template (seems an hard task), give <em>rdoc</em> access to my <span class="caps">CSS</span> file, etc. However, there&#8217;s an easier way: the <a href="http://rdoc.sourceforge.net/doc/classes/SM/SimpleMarkup.html">SimpleMarkup</a> class, that I&#8217;ve found quickly thanks to the sentence <em>If you want to use the library to format text blocks into <span class="caps">HTML</span>, have a look at SM::SimpleMarkup.</em> appearing <a href="http://rdoc.sourceforge.net/doc/index.html">here</a>. Moreover, the developer of <em>rdoc</em> seems to be Dave Thomas, a really famous <a href="http://www.pragprog.com/">pragmatic programmer</a> ! Good news: it looks like code that I can reuse!</p>
<p>The <tt>SimpleMarkup</tt> class parses your plain text file, recognizes the simple markup language of <em>rdoc</em>, and its companion class <tt>ToHtml</tt> generates <span class="caps">HTML</span> from the parsing result. Moreover, you can install you own recognition patterns in order to extend the markup language. Exactly what I need: a simple <span class="caps">HTML</span> text file (without <tt><html><body></body></html></tt> tags) generated from a simple plain text file!</p>
<h3>Embedding generated <span class="caps">HTML</span> in a template</h3>
<p>The <span class="caps">HTML</span> generated by <tt>ToHtml</tt> is not aware of the template I use. So I still need to embed it in order to get well formed <span class="caps">HTML</span> documents. This time (or once again), I will implement it myself! The reason is that, a long time ago, I&#8217;ve invented my own  templating language which is called <em>wlang</em> (for some obsure reasons). I will certainly <a href="wlang">talk deeply about wlang</a> on this blog later; today, I will introduce only a small subset of its features:</p>
<ol>
	<li><em>wlang</em> is not designed to generate <span class="caps">HTML</span> specifically. It is designed to generate text files in general. However, I must confess that I use it mainly for <span class="caps">HTML</span>/<span class="caps">XML</span> generation.</li>
	<li><em>wlang</em> takes a text file as input and generates mostly the same text file as output. The only thing it does is replacing special markups like <tt>${varname}</tt>, <tt>+{varname}</tt> and <tt>@{varname}</tt> by something else. Replacements performed by these operators are called <em>injection</em>, <em>inclusion</em> and <em>linking</em>, respectively. <em>varname</em> is an abstract reference to some program variable (abstract here means that it depends on the implementation).</li>
	<li>The difference between these three operators is a follows (assuming that we generate <span class="caps">HTML</span> specifically):</li>
</ol>
<table>
<tr>
    <td><code>${varname}</code></td>
    <td>injects the value of the variable <tt>varname</tt> as plain text embedded in the <span class="caps">HTML</span> (that is, the value <span class="caps">MUST</span> be entities-encoded: if the variable contains <code>&lt;script&gt;...&lt;/script&gt;</code> for example, it will never generate an <span class="caps">HTML</span> tag) ! That is, your templating engine takes care of disallowing basic <span class="caps">XSS</span> attacks (unless robust validation technique is used, this operator should always be used for inclusion of user data in the page, i.e. data coming from an <span class="caps">HTML</span> form for example).</td>
</tr>
<tr>
    <td><code>+{varname}</code></td>
    <td>includes the value without encoding, which is powerful for a templating engine, but should be used with care!</td>
</tr>
<tr>
    <td><code>@{varname}</code></td>
    <td>renders the value as an address link. The exact behavior of this operator would bring me too far. However, note that, in the case at hand, it does not generate a complete <code>&lt;a&gt;...&lt;/a&gt;</code> link, but only the content of the <em>href</em> attribute.</td>
</tr>
</table>
<p>Enough for today about <em>wlang</em>. The solution to my problem is so simple now: this page is generated from a <em>wlang</em> template, containing <code>${title}</code> (in the header), <code>@{next}</code> and <code>@{previous}</code> (for the two links at the top of the page, really simply done thanks to my .htaccess file, see the first revision) and <code>+{contents}</code> for the article text here. That&#8217;s it! Details can be found in the implementation below.</p>
<h3>The implementation</h3>
<p>The Ruby implementation of the tool I&#8217;ve built to help me in my writing task simply consists of two classes: <tt>RevZeroMarkupRecognizer</tt> and <tt>RevZeroTemplateInstanciator</tt> for the two sub tasks presented before.</p>
<p>As I did not have a <em>wlang</em> implementation in Ruby so far, I&#8217;ve implemented only the subset presented before. Ruby is a fantastic programming language: the core method of the corresponding class looks like this:</p>
<div class="highlight"><pre><span class="c1">#</span>
<span class="c1"># Instanciates the _wlang_ template using key/value pairs given by _hash_. </span>
<span class="c1"># _buffer_ is expected to be an IO object. Raises a RuntimeError if a </span>
<span class="c1"># reference to an unexisting variable is found.</span>
<span class="c1">#</span>
<span class="c1"># Following markups are recognized:</span>
<span class="c1"># - ${varname} are replaced by the entities-encoding of hash[varname] </span>
<span class="c1"># - +{varname} are replaced by hash[varname] without encoding</span>
<span class="c1"># - @{varname} are replaced by the result returned by the _varname_ singleton </span>
<span class="c1">#              method.</span>
<span class="c1">#</span>
<span class="k">def</span> <span class="nf">instantiate</span><span class="p">(</span><span class="nb">hash</span><span class="p">,</span> <span class="n">buffer</span><span class="p">)</span>
  <span class="no">File</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="vi">@template</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">f</span><span class="o">|</span>
    <span class="n">f</span><span class="o">.</span><span class="n">each_line</span> <span class="k">do</span> <span class="o">|</span><span class="n">line</span><span class="o">|</span>
      <span class="c1"># matches ${...}, +{...} and @{...}</span>
      <span class="k">while</span> <span class="n">matchdata</span> <span class="o">=</span> <span class="sr">/([$+@])\{([^\}]+)\}/</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
        <span class="n">tagtype</span><span class="p">,</span> <span class="n">varname</span> <span class="o">=</span> <span class="n">matchdata</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span><span class="p">,</span> <span class="n">matchdata</span><span class="o">[</span><span class="mi">2</span><span class="o">]</span>
        <span class="n">buffer</span> <span class="o">&lt;&lt;</span> <span class="n">matchdata</span><span class="o">.</span><span class="n">pre_match</span>
        <span class="k">case</span> <span class="n">tagtype</span>
        <span class="k">when</span> <span class="s1">&#39;$&#39;</span> <span class="c1"># reference to a variable (encoding required)</span>
          <span class="k">raise</span> <span class="s2">&quot;No data found for </span><span class="si">#{</span><span class="n">varname</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">unless</span> <span class="nb">hash</span><span class="o">.</span><span class="n">has_key?</span><span class="p">(</span><span class="n">varname</span><span class="p">)</span>
          <span class="n">buffer</span> <span class="o">&lt;&lt;</span> <span class="vi">@encoder</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="nb">hash</span><span class="o">[</span><span class="n">varname</span><span class="o">]</span><span class="p">)</span>
        <span class="k">when</span> <span class="s1">&#39;@&#39;</span> <span class="c1"># reference to an action, we use singleton methods here</span>
          <span class="k">raise</span> <span class="s2">&quot;Action </span><span class="si">#{</span><span class="n">varname</span><span class="si">}</span><span class="s2"> not found&quot;</span> <span class="k">unless</span> <span class="nb">self</span><span class="o">.</span><span class="n">respond_to?</span><span class="p">(</span><span class="n">varname</span><span class="p">)</span>
          <span class="n">buffer</span> <span class="o">&lt;&lt;</span> <span class="nb">self</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">varname</span><span class="p">)</span>
        <span class="k">when</span> <span class="s1">&#39;+&#39;</span> <span class="c1"># Template inclusion (no encoding)</span>
          <span class="k">raise</span> <span class="s2">&quot;No data found for </span><span class="si">#{</span><span class="n">varname</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">unless</span> <span class="nb">hash</span><span class="o">.</span><span class="n">has_key?</span><span class="p">(</span><span class="n">varname</span><span class="p">)</span>
          <span class="n">buffer</span> <span class="o">&lt;&lt;</span> <span class="nb">hash</span><span class="o">[</span><span class="n">varname</span><span class="o">]</span>
        <span class="k">end</span>
        <span class="n">line</span> <span class="o">=</span> <span class="n">matchdata</span><span class="o">.</span><span class="n">post_match</span>
      <span class="k">end</span>
      <span class="n">buffer</span> <span class="o">&lt;&lt;</span> <span class="n">line</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>  
</pre></div>
<p>The entire code of this article being really specific to what I&#8217;m doing for this blog, I won&#8217;t give it for download. However, feel free to send me an email if you want to have a copy (under a <span class="caps">GPL</span> licence). I&#8217;m also pretty sure that a more complete Ruby implementation of <em>wlang</em> will appear here soon!</p>
<p>See you at <a href="2">revision 2</a> !</p>