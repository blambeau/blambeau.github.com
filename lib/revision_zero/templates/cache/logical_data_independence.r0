<p>I&#8217;m really happy to write about databases today! The Relational model, invented by Edgar F. Codd, might have been born about 40 years ago (the official paper is dated from 1970, but the first draft was actually written in 1969) but in my opinion a lot of research and development still needs to occur for Codd&#8217;s dream to become a reality.</p>
<p>For a really long time, I wanted to write somewhing about what has been called &#8216;logical data independence&#8217; but I didn&#8217;t  find a good example to illustrate that concept until today. I&#8217;ve just found it now, inspired from a real but simple  application! So let&#8217;s talk about it. The topic matters: even famous computer scientists wrongly confuse logical and physical data independence&#8230; and developers don&#8217;t even imagine how such an independence could make their job easier! Nevertheless I must confess that logical data independence is somewhat loosely defined&#8230; Therefore let me start by sharing my developper&#8217;s point of view on what it means.</p>
<h3>Independence??</h3>
<p>What does &#8216;logical (data) independence&#8217; mean? Well, there are two axes in there: the concept of &#8216;independence&#8217;, and the &#8216;logical&#8217; one ;-) The concept of &#8216;independence&#8217; is related to &#8216;change&#8217;; the main question &#8216;independence&#8217; addresses is &#8216;how does a given change affect the code of the software ?&#8217;. That is something that can be measured: decide to make a change to the current version of your software, implement it, commit it, and count the number of lines of code that have changed between the two versions. Actually, tallying up the numbers of changed lines is not the best measure and I strongly prefer counting how many packages/modules (if you have an abstract module decomposition) and/or classes (if you don&#8217;t) have been affected by the change.</p>
<p>At the risk of sounding like a theorist, &#8216;change&#8217; can also be seen in the light of requirements. What are changing requirements? Well, there&#8217;s a lot to it but the most important in my experience is &#8216;New requirements&#8217;. In other words, the need for new features! New features are much more important than everything else: they demonstrate that the software is living, that people use it, like it (at least, we hope so), and want it to evolve! I like new features, and I like new features a lot more if developing them does not affect the code of existing ones. This is where independence comes into play! To me, independence is the complementary of rigourous testing: tests assert that requirements are still met (and by transitivity that features implementing them seem correct) when the code needs to change; independence helps avoiding to have to alter existing code too much when implementing requirement changes.</p>
<p>In this article, I am talking about &#8216;data independence&#8217;. My point so far was about &#8216;architectural independence&#8217; at large, also called &#8216;weak coupling&#8217;: two modules are weakly coupled if changing the code of one does not affect the second. In fact, we should make the distinction between two kinds of code modification. A module has an external specification (and an external, public <span class="caps">API</span> together with pre and post-conditions) and an internal specification (and internal, private implementation). So, independence is two-fold: how is the second module affected by an external change to the first one (modification and/or extension of the <span class="caps">API</span>, for example)? and by an internal change? A good architecture (and the introduction of object-oriented programming in practice) provides well designed APIs, allowing strong independence when making internal changes; external changes are another story, of course!</p>
<p>A database is nothing else than a specific architectural module. Therefore the same internal/external distinction can be made and similar questions may be asked: how is the software code (all but the database code, that is) affected by an internal/external change of the database? Loosely speaking, this distinction is well known and largely described in books as the difference between &#8216;physical&#8217; and &#8216;logical&#8217; data independence. The first level has been achieved for a long time now (but seems to somewhat disappear in my opinion) but the second one has never been reached (in my opinion still). Let&#8217;s briefly discuss physical independence first!</p>
<h3>Physical data independence</h3>
<p>A long time ago (in the 60&#8217;s and 70&#8217;s, I wasn&#8217;t even born&#8230;), when you had to keep information about employees working in departments, you typically kept records about employees in a flat file and maintained a pointer to the department record in the employee record. To create a report with employees belonging to a given department, you had to iterate employees&#8217; records in the flat file (through file cursors and such kind of physical abstractions), gathering those that reference the correct department record by following the pointer. When the way the data was kept on disk was changed (for example through the introduction of an index file directly mapping the list of employees engaged in a given departement), the report&#8217;s code had to change as well (to take profit of this new index, for performance of course ;-))!</p>
<p>With the introduction of the Relational model (and <span class="caps">SQL</span> databases, which are the best (non-)relational implementation we have today), things have changed. The report&#8217;s code is some variation around &#8220;<span class="caps">SELECT</span> * <span class="caps">FROM</span> <span class="caps">EMPLOYEES</span> <span class="caps">WHERE</span> DEPT_id=&#8216;<i>foo</i>&#8217;&#8221;. The most important thing is not that this query is declarative (it&#8217;s probably required for independence, but not important <i>per se</i>) but the fact that it is independent of the way the data is physically stored: flat files, B-trees, hash indexes can all be chosen as physical storage and indexing of employee and department records as well as their &#8216;connection&#8217; through DEPT_id provided without affecting the report&#8217;s code itself (the query always remains the same query because the logical schema does not change)!</p>
<p>So when talking about changes: you can add or remove indexes, change the way base tables are kept on disk, etc. without affecting the application&#8217;s code. The responsibility of ensuring that the query can be executed and returns the correct results as well as the choice of available information paths used to do so (what index will be used, for example) is left to the database management system (<span class="caps">DBDM</span>), not the application itself. This is what physical independence means!</p>
<h3>Database specifications</h3>
<p>Let turn back briefly to the architectural discussion above. Codd&#8217;s work on the relational model and databases has strongly improved the separation between the external and internal specifications of a database:</p>
<p><b>External specification</b>: the database module offers the ability to express &#8216;what&#8217; the data of interest is for a given task (as in our report example), through a logical schema of the data (strongly rooted in mathematics, and first order logic in particular) and &#8216;deduction operators&#8217; (the relational algebra) that allow that data to be queried (the term &#8216;deduction&#8217; comes from the fact that if a database is a collection of known facts &#8211; and it is! &#8211; then a query does nothing else than deducing new facts from existing ones). More generally, the external specification of a database is that it respects <span class="caps">ACID</span> properties (Atomicity, Consistency, Isolation and Duration), and the fact that query results are always correct is related to Consistency.</p>
<p><b>Internal specification</b>: no matter what information paths are choosen (for example index selection) for executing a particular query, the query execution must return correct results. Moreover, we expect the database implementation to be smart enough to select a good query plan ensuring a good query execution performance. This is where the query optimizer comes into play, turning the 60&#8217;s developer (who was selecting information path by explicit application coding) to the 80&#8217;s database administrator (who creates new indexes, analyzes query plans and so on, independently of the application code itself). More generally, the internal specification is related to the effective implementation of the <span class="caps">ACID</span> properties through extremely complex physical mechanisms that you don&#8217;t have to worry about as an application developer. Thanks a lot Mr Codd!</p>
<h3>Logical data independence</h3>
<p>What about logical data independence? According to database books, physical independence means <b>non-intrusive changes of the physical schema</b> where logical independence means <b>non-intrusive changes of the logical one</b>. Physical schema modifications are generally well discussed in database books (index creation, suppression, and so on) and the physical independence well understood by students (they often forget everything about it a bit later, of course!). Examples of logical schema modification are much less convincing in my opinion: renaming or suppression of an attribute (or a table column, if you prefer that vocabulary), removal of a table, and so on. They are logical schema changes, of course, but not good examples! Strictly speaking if I remove a database table for real, I don&#8217;t see how the application code using that table could not be affected&#8230;</p>
<p>Better books relate logical independence to views &#8230; without providing any convincing example I must add. However, it is perfectly correct! Logical independence is strongly related to views. I would add that a database that does not provide a real, complete and transparent view mechanism (including a way to update views) is strictly unable to provide logical data independence. Strictly speaking, views do not offer logical data independence <i>per se</i> but they are the way (or at least one of the best ways) to achieve that goal. I&#8217;ve stated earlier that &#8220;logical independence has never been reached&#8221;&#8230; I close this first paper with a short explanation of that sentence: few <span class="caps">DBMS</span> provide a good view mechanism, few <span class="caps">SQL</span> <span class="caps">DBMS</span> allow updating views (automatically or through triggers or rules written by the <span class="caps">DBA</span>), no support is provided by <span class="caps">SQL</span> <span class="caps">DBMS</span> to manage logical changes through successive schema versions and few DBAs know how to use views in the correct way.</p>
<p>The story does not end here, of course. The <a href="logical_data_independence_2">next paper</a> will show a real but simple (and I hope convincing) example of what &#8216;logical data independence&#8217; may really mean in practice.</p>