<p>I&#8217;ve been talking about <em>logical data independence</em> <a href="logical_data_independence">here</a>, about source code independence <a href="book#how">there</a>, and so on. It&#8217;s probably time to provide some lecture about <em>independence</em> in the large when talking about computer science.</p>
<p>I wanted to start this post with a quick review of google results for &#8220;computer science independence&#8221; or &#8220;software architecture independence&#8221;. I have to admit that the results are not really convincing&#8230;</p>
<p>In my opinion, one of the major weaknesses of computer science nowadays is the lack of theoretical abstraction. For instance, good students of mine know about java interfaces, but they don&#8217;t have any insight of general principles underlying the <em>reason of introducing interfaces</em>&#8230; Whatever your profile, <strong>knowing good principles is always better than knowing practical tips and tricks !</strong></p>
<h3>What does independence mean?</h3>
<p>Independence in computer science is both about <em>change</em> and about <em>abstraction</em>. More precisely, <em>reaching independence</em> means <em>using the good abstractions</em> to allow the software not to be too much hurt by <em>changes</em>.</p>
<h3>What kind of change?</h3>
<p>Changes may be numerous and of different nature. The list below is a open-ended proposal, don&#8217;t hesitate to ask questions or to start a discussion about practical examples.</p>
<table>
	<tr>
		<td><code>Assumptions</code></td>
		<td>Your software always makes a lot of assumptions about its environment, some of them being implicit, others being well known and/or documented. The second are generally easy to handle&#8230; while the former are killers.</td>
	</tr>
	<tr>
		<td><code>Requirements</code></td>
		<td>Probably the worst&#8230; changing requirements (what the software is supposed to do) often means changing the implementation in depth. How to react to changing requirements?</td>
	</tr>
	<tr>
		<td><code>Evolution</code></td>
		<td>New features? Great! New features generally means that the software is being adopted by its users. But how to implement new features without breaking existing ones?</td>
	</tr>
	<tr>
		<td><code>Third party</code></td>
		<td>Almost all softwares use third party libraries/tools/devices. Those components also change and these changes may affect portability/stability/robustness of your software. How to get away from third party changes?</td>
	</tr>
	<tr>
		<td><code>Optimization</code></td>
		<td>People want softwares to act fast, and always faster. Optimizing means <em>changing the base code</em> to handle such requests. More precisely, optimizing commonly means <em>changing the implementation</em>, in contrast to the <em>specification</em>. Optimization is unfortunately often premature, and even dangerous if it leads to breaking features. How to optimize the good way?</td>
	</tr>
</table>
<h3>Coding patterns in presence of changes</h3>
<p>First of all, agile developers are right: <strong>changes occur</strong>.  You can&#8217;t prevent them. Loosely speaking, there are two ways to face <em>changes</em>. The pragmatic way: <em>accept them and react accordingly</em>. The theoretical one: <em>anticipate changes</em> with good requirements, good architecture and so on. These two approaches are <strong>not</strong> antagonistic. Coding patterns below are practical things (something that you apply for real), but many of them are inspired by sound principles (something more abstract that you know the merits, see next section).</p>
<p><strong><code>Testing</code></strong>: Are you already applying <em>test driven development</em>? No? <strong>Give it a chance</strong>&#8230; <strong>now!</strong> It helps you making <u>assumptions</u> explicit, thinking about <u>requirements</u>, detecting <u>third party</u> changes and not fearing major <u>optimization refactorings</u>. When I start learning a new third party library, I write tests and assert my own understanding of that library. Such sandbox tests stay alive with your software, providing a shield about third party changes and  ensure that your assumptions stay correct. Also, the first thing I do before optimizing is convincing myself that I&#8217;ve reach a good black box test coverage of the chunk of code I plan to refactor, by writing additional tests of course. And so on.</p>
<p><strong><code>Encapsulating uncertainty</code></strong>: When I&#8217;m not sure about something (related to <u>assumptions</u>, <u>requirements</u> and <u>third party</u>) I encapsulate my uncertainty inside a given function/class/method/package/whatever with an extremely precise (and strong) specification. Some examples:</p>
<ul>
	<li>The documentation of a third party method behavior is vague? Encapsulate calls to it with something stronger!</li>
	<li>Hesitating between interfacing with an external library, copying (open-source) code from it or re-implementing features of interest? Write a facade in front of the features you use.</li>
	<li>Not sure how a method is supposed to behave in a specific situation &#8211; maybe because the problem it solves is not completely specified yet? Detect the unsupported case and raise an error: for the caller, <em>having a strong post-condition</em> (an error is raised in that case) is always better than <em>hoping that it will pass</em>.</li>
</ul>
<p>These techniques are extremely powerful: in all cases, you <strong>replace vagueness and uncertainty by strong certitudes</strong>. Detecting and reacting to future changes will be a lot easier.</p>
<p><strong><code>Preprocessing</code></strong>: An important source of change is <em>input change</em> (related to <u>requirements</u> and <u>evolution</u>). Many software modules &#8220;consume&#8221; some data and the way this data is described (i.e. data structures are used) is of critical importance. Each module should <strong>work on a data-structure that makes its implementation easy</strong> and intuitive. For instance, if a web page presents a big table of results, its input should be a big table of data&#8230; and if it presents a tree, its input should be a tree. Preprocessing simply means introducing data converters where needed. A counter-example: the previous table is rendered by navigating through an entire object model (typical with ORMs), following associations, making counts, etc. Such a rendering technique will be strongly hurt by changes in the object structure. Encapsulating the conversion between the object model and a big table of data inside a dedicated (and well tested) function will evolve a lot better! Even <u>optimization</u> of that function will be easier.</p>
<p><strong><code>Abstracting</code></strong>: In my opinion, the nature of computer science and the best pattern for software <u>evolution</u>. Unfortunately, this pattern is also the most difficult to use the right way and the most dangerous: abstracting too much definitely kills your software! Abstracting is difficult to define&#8230; let start with the <a href="http://en.wikipedia.org/wiki/Abstraction">wikipedia definition of <em>abstraction</em></a>:</p>
<blockquote>
<p>Abstraction is the process or result of generalization by reducing the information content of a concept or an observable phenomenon, typically to retain only information which is relevant for a particular purpose.</p>
</blockquote>
<p>The last part of this sentence is worth reading! Let me discuss the <a href="book#how">example of blog&#8217;s links</a>. From the point of view of the blog sources (the format I use for writing these papers), a link is a pair: <em>identifier</em> of a target location and <em>label</em> to render:</p>
<div class="highlight"><pre> Let me discuss my @{book#how}{example of blog&#39;s links} 
</pre></div>
<p>This abstraction is sufficient: it encloses the relevant information for the practical purpose of what a link <em>is</em> in the blog sources. The way theses links are &#8220;implemented&#8221; (by a <em>href and url</em> or a <em>onclick and ajax</em>) is another story&#8230; From a development point of view, abstracting is enforcing a separation between (un)related concerns: <em>specification</em> from <em>implementation details</em>, for instance.</p>
<h3>Principles underlying those coding patterns</h3>
<p>The patterns presented before are practical coding patterns. The reason of using them is driven by theoretical concepts that are even more important. Below are four abstract concepts that drive my developer&#8217;s work almost everyday:</p>
<p><strong><code>Coupling</code></strong> in software architecture captures the notion of dependency links between modules. Two modules are strongly coupled if the dependency link between them is so strong that changing one of them will necessary imply changing something in the second one as well. A good architecture enforces <strong>weak coupling</strong>. Introducing interfaces (in Java, for instance) generally means <em>reducing coupling</em> by <u>Abstracting</u> (provided that the interface is well designed, I should add). <u>Preprocessing</u> and <u>Encapsulating uncertainty</u> patterns above also help reducing coupling a lot.</p>
<p><strong><code>Cohesion</code></strong> Many authors relate cohesion and coupling. While not being wrong, it is a bit subtle. Cohesion captures the notion of <em>doing few, but doing it well</em>. Somewhat strangely, a <strong>strong cohesion</strong> <em>reduces</em> coupling even if it introduces dependency links (ensuring cohesion naturally implies having more &#8211; related &#8211; modules). The explanation about this fact relies in the kind of dependency we are talking about. Let&#8217;s go back to the <u>Preprocessing</u> example about rendering a result table in <span class="caps">HTML</span>: a template renders data, prepared by a specific function. Both have a strong cohesion, but the former depends on the second. However, the dependency link is weaker than expected: even if the data is wrong, the template may render it. As an interesting consequence, each module can be tested independently. And when both are correct, their integration is probably correct as well: the table presents accurate results. This discussion naturally leads me to the next point.</p>
<p><strong><code>Separation of concerns</code></strong> is the general principle underlying <em>problem decomposition</em>, where small achievements taken altogether allow a bigger one. In my experience, separation of concerns is also <span class="caps">THE</span> key notion to apply the <u>Abstracting</u> coding pattern the best way. Introducing abstractions without gaining along the separation of concerns may lead to an <span class="caps">API</span> which is  less stable, harder to understand and harder to maintain.</p>
<p><strong><code>Information hiding</code></strong> captures a notion of module <em>secret</em>. This is an interesting question to ask yourself when designing an architecture: what is the secret of each module? If you can&#8217;t answer that question, there&#8217;s probably something wrong in the decomposition. Think about the <em>Encapsulate uncertainty</em>, <em>Preprocessing</em> and (though somewhat less) <em>Abstracting</em> coding patterns: all of them force encapsulating &#8220;design choices&#8221; (which external library? where does the data come from? how is a link actually rendered in an <span class="caps">HTML</span> page? and so on.) in specific places; in other words, all of them introduce secrets, all of them help reaching <strong>strong information hiding</strong>.</p>
<p>There is something really nice these four theoretical principles: they are extremely correlated! Encapsulating a specific design choice by introducing a new module, for instance, generally reduces coupling, introduces a better separation of concerns, and naturally leads to a good cohesion and information hiding at that place. Unfortunately, the reverse is also true: forget to encapsulate some design choice and you&#8217;ll also augment coupling and reduce cohesion. If that design choice is questioned later, the software will likely be extremely difficult to refactor&#8230; and reacting to changes will be challenging.</p>
<p>A simple word, <em>independence</em>, sometimes requires a long discourse ;-)</p>
<h3>Credits</h3>
<p>Coding patterns are mine. I&#8217;m really grateful to Axel van Lamsweerde (my thesis promotor), for introducing me to the underlying principles in his Requirements Engineering course<sup class="footnote" id="fnr1"><a href="#fn1">1</a></sup>. While not being sure about their origin, I think that those principles have been initially proposed by David Parnas<sup class="footnote" id="fnr2"><a href="#fn2">2</a></sup> and Barry Boehm<sup class="footnote" id="fnr3"><a href="#fn3">3</a></sup>. Anyway, these authors propose excellent lectures about them.</p>
<h3>References</h3>
<p class="footnote" id="fn1"><a href="#fnr1"><sup>1</sup></a> Axel van Lamsweerde, <em>Requirements Engineering: from system goals to <span class="caps">UML</span> models to software specifications</em>, Wiley, 2009.</p>
<p class="footnote" id="fn2"><a href="#fnr2"><sup>2</sup></a> David Parnas, <em>&#8220;Software Aging&#8221; in Software Fundamentals</em>, Addison-Wesley, 2001, pg. 557-558, 563.</p>
<p class="footnote" id="fn3"><a href="#fnr3"><sup>3</sup></a> Barry Boehm. <em>Software Cost Estimation with <span class="caps">COCOMO</span> II</em>, Prentice Hall, 2000, pg. 23, 28.</p>