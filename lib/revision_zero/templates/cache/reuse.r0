<p>With colleagues we have a somewhat recurrent discussion about <em>software reuse</em>. Discussion has raised once again recently, so I decided to summarize my personal point of view on this blog. After a short review of a good (yet already old) paper from the scientific literature, I would like to discuss the specific difficulties I&#8217;ve almost always encountered in my own work and my two-cents proposal to have more effective reuse in practice. I start with the paper review in this post; in the next one I&#8217;ll try to provide a more practical lecture of software reuse.</p>
<h3>A short review of a survey</h3>
<p>The concept of <em>software reuse</em> is not new and many writings already exist about it. Probably the better I&#8217;ve read so far is a review due to Charles W. Krueger published in 1992 and simply entitled <em>Software Reuse</em><sup class="footnote" id="fnr1"><a href="#fn1">1</a></sup>. The abstract starts with the following paragraph:</p>
<blockquote>
<p>Software reuse is the process of creating software systems from existing software rather than building software systems from scratch. This simple yet powerful vision was introduced in 1968 (ed. in <sup class="footnote" id="fnr2"><a href="#fn2">2</a></sup>). Software reuse has, however, failed to become a standard software engineering practice. In an attempt to understand why, researchers have renewed their interest in software reuse and in the obstacles to implementing it.</p>
</blockquote>
<p>The paper is actually a survey of the research efforts at that time about <em>reuse techniques</em>. The techniques discussed are (I will briefly discuss each of them a bit later):</p>
<blockquote>
<p><em>high-level languages</em>, <em>source code components</em>, <em>software architectures</em>, <em>design and code scavenging</em>, <em>application generators</em>, <em>transformational systems</em>, <em>very high-level languages</em> and <em>software schemas</em>.</p>
</blockquote>
<p>Each technique is more fully described in the body of the paper (a section of 2 to 3 pages each). There, they are  classified along four main dimensions:</p>
<ul>
	<li><strong>Abstraction</strong>. What are the ``software abstractions&#8217;&#8217; introduced by the reuse technique? In other words what is the type of software artifacts that are reused and what abstractions describe them?</li>
	<li><strong>Selection</strong>. How are the reusable artifacts intended to be selected for reuse? How to locate and compare them, for example?</li>
	<li><strong>Specialization</strong>. Artifacts are generalizations. Reusing an artifact implies having a way to specialize it back (through parameters, constraints, &#8230;). How is this achieved for each technique?</li>
	<li><strong>Integration</strong>: How are reusable artifacts integrated inside the complete software system under construction?</li>
</ul>
<p>The paper also aims at <em>evaluating</em> the effectiveness of the reuse techniques, or at least it gives clues to do so. For this it calls for gauging the effectiveness of a reuse technique in terms of <em>cognitive distance</em>, that is, in terms of the <em>intellectual effort required (by software developers) to use it</em>. Interestingly, the author points out in his conclusion that the cognitive distance can be reduced in two ways:</p>
<ul>
	<li>by reducing the intellectual effort required to go <strong>from the conceptualization of a system to a specification</strong> in the abstractions proposed by the reuse technique and,</li>
	<li>by reducing the effort required to <strong>produce an executable system from that specification</strong>.</li>
</ul>
<p>The paper also provides an approximate ranking of the height reuse techniques, rated on how well they minimize cognitive distance by each of the two methods mentioned above. <em>Application generators</em> win the first ranking while <em>high level languages</em> win the second one (refer to the paper for details).</p>
<h3>A first personal opinion</h3>
<p>I&#8217;d like to close the paper review with something maybe more subjective. First, we can argue retrospectively about the effectiveness of the reuse techniques. The same certainly applies about the paper rankings. My personal feeling however is that the rankings are quite convincing even if not all reuse techniques suffer the same success. Second, I would like to point out how relevant the <em>research method</em> seems to me (don&#8217;t forget that the paper has been published in 1992):</p>
<ul>
	<li>most of the reusable artifacts and reuse techniques I know and use everyday are covered by this survey,</li>
	<li>in my opinion, the four dimensions chosen for classifying them still give remarkable clues today for comparing and improving the tools we have,</li>
	<li>when evaluating the effort required to apply a reuse technique, the notion of <em>cognitive distance</em> and the relevance of distinguishing between ease of specification (in terms of reusable abstractions) and ease of realization (i.e. obtaining an executable) is definitely worth considering &#8230; and should be considered much more often, <span class="caps">IMHO</span> (at the risk of making a forward reference: your technique/language/library/whatever is only effective if it helps gaining both ways, or at least if gaining one way is not at the expense of the other).</li>
</ul>
<p>Of course, I&#8217;ll specifically refer to these points later in this post. Before actually discussing the specific difficulties I encounter in practice, I would like to review the different reuse techniques discussed in the paper in the light of the languages and tools I personally use at the time of writing.</p>
<h3>Quick overview of Reuse Techniques</h3>
<p>Nowadays, no one would seriously argue that <em>software reuse has failed to become a standard software engineering practice</em>. Let have a quick look at each of the technique mentioned in the paper, in the light of the tools we have today. Note that I&#8217;ve tried to be consistent with the paper, in terms of the software abstractions behind each reuse technique. Some of the terms used in the paper may have a slightly different meaning today. Also note that the different techniques may overlap, as already pointed implicitly by Krueger himself. I must add that the presentation order I&#8217;ve chosen is related to my own understanding of the concepts ;-) Therefore, all subtitles and some other links below can be used easily to launch a google search!</p>
<h4><a href="http://www.google.com/search?q=High%20Level%20Languages" target="_blank">High Level Languages</a></h4>
<p><a href="http://www.google.com/search?q=C%20programming%20language" target="_blank">C</a>, <a href="http://www.google.com/search?q=Camel%20programming%20language" target="_blank">Camel</a>, <a href="http://www.google.com/search?q=Clojure%20programming%20language" target="_blank">Clojure</a>, <a href="http://www.google.com/search?q=Factor%20programming%20language" target="_blank">Factor</a>, <a href="http://www.google.com/search?q=Go%20programming%20language" target="_blank">Go</a>, <a href="http://www.google.com/search?q=Haskell%20programming%20language" target="_blank">Haskell</a>, <a href="http://www.google.com/search?q=Java%20programming%20language" target="_blank">Java</a>, <a href="http://www.google.com/search?q=Javascript%20programming%20language" target="_blank">Javascript</a>, <a href="http://www.google.com/search?q=Lua%20programming%20language" target="_blank">Lua</a>, <a href="http://www.google.com/search?q=Python%20programming%20language" target="_blank">Python</a>, <a href="http://www.google.com/search?q=Ruby%20programming%20language" target="_blank">Ruby</a>, <a href="http://www.google.com/search?q=Smalltalk%20programming%20language" target="_blank">Smalltalk</a> and so on., high level languages are numerous and various. Each one comes with its set of tools to raise the abstraction level (sometimes in certain respects only, like providing good abstractions for concurrency, or low-level tasks).</p>
<h4><a href="http://www.google.com/search?q=Source%20code%20components" target="_blank">Source code components</a></h4>
<p>High level languages also come with effective abstractions to build and share &#8220;abstract data types&#8221; and other &#8220;reusable libraries&#8221;. Source code components are generally intended to be used as black-boxes: a public interface of usage is announced, formally or not (ruby has not equivalent of java interfaces, for example), while the realization of this interface is kept hidden (or at least intended to be). Think to C libraries, java&#8217;s .jars, python&#8217;s modules, ruby&#8217;s gems, and so on. In many languages, &#8220;find a component, download it, and go&#8221; has become a reality!</p>
<h4><a href="http://www.google.com/search?q=Software%20architectures" target="_blank">Software architectures</a></h4>
<p>Software architectures are large-grain software frameworks. In contrast with source code components which are often black-boxes, software architecture are designed as grey-boxes: they are intended to be extended and provide specific extension points for this. We have a lot of reusable frameworks nowadays. Probably the most common are <em>web frameworks</em> (<a href="http://rubyonrails.org/">Ruby on Rails</a>, <a href="http://www.djangoproject.com/">django</a>, <a href="http://www.asp.net/"><span class="caps">ASP</span>.net</a>, &#8230;), <em>integrated development environment</em> (<span class="caps">IDE</span>, <a href="http://www.eclipse.org/">Eclipse</a> is worth mentioning due to its architecture), <em>service oriented architectures</em> (<span class="caps">SOA</span>), and so on.</p>
<h4><a href="http://www.google.com/search?q=Design%20and%20code%20scavenging" target="_blank">Design and code scavenging</a></h4>
<p>Design and code scavenging is simply a form of &#8220;find, copy-paste, adapt&#8221;. The well-known design patterns<sup class="footnote" id="fnr3"><a href="#fn3">3</a></sup> provide an organized form of <em>design scavenging</em>, by providing <em>catalogues</em> for applying such kind of reuse.  Even if invented in the context of the object-oriented programming, design patterns had a great impact far beyond that programming paradigm.</p>
<p><em>Code scavenging</em> is less organized as few such catalogues exists. Every day however, the web gives use better ways to apply such a reuse technique: <a href="http://www.google.com/codesearch">google code search</a>, <a href="https://gist.github.com/">github&#8217;s gist</a>, <a href="http://www.pastie.org/">pastie</a>, and so on. I also remember having read an book about Eclipse<sup class="footnote" id="fnr4"><a href="#fn4">4</a></sup> whose authors encouraged applying the <a href="http://www.google.com/search?q=monkey%20see,%20monkey%20do" target="_blank">monkey see, monkey do</a> rule, that is, copy pasting code from other Eclipse plugins whose source code is available.</p>
<h4><a href="http://www.google.com/search?q=Application%20generators" target="_blank">Application generators</a></h4>
<p>The paper compares <em>application generators</em> with <em>software compilers</em>. According to it, generators differ from compilers in that <em>the input specifications are typically very high level, special-purpose abstractions from a very narrow application domain</em>. I would add that compilers traditionnaly transform source code from a high-level language to something which is intended to be executable by a (virtual) machine, while application generators transform (very) high level descriptions into code that generally need to be compiled in turn.</p>
<p>In that sense, parser generators (<a href="http://dinosaur.compilertools.net/">lex &amp; yacc</a>, <a href="http://www.antlr.org/">antlr</a>, <a href="http://cs.nyu.edu/rgrimm/xtc/rats.html">rats!</a>, <a href="http://treetop.rubyforge.org/">treetop</a>, <a href="http://fdik.org/pyPEG/">pyPEG</a>, and so on.) are probably the best-known examples of application generators. Other examples include wizards that one can find in Integrated Development Environments (to design and generate code of user interfaces, for example), tools that generate classes from <span class="caps">UML</span> class diagrams, generators of database schemas, report generators, etc. In note in passing that the <a href="noe">Noe library I was talking about recently</a> is of course a kind of application generator.</p>
<h4><a href="http://www.google.com/search?q=Transformational%20systems" target="_blank">Transformational systems</a></h4>
<p>Transformational systems are the holy grail of computer science, nothing less! In that paradigm, software developers actually describe the behavior of the software using a high-level specification language (related to <span class="caps">VHLL</span> described before). In a second phase, the specifications are transformed in order to produce an executable system. The transformations are meant to enhance efficiency without changing the semantics.</p>
<p>Transformational systems emphasizes the <em>what</em> instead of the <em>how</em>. They actually bet on the concision of declarative statements over procedural ones to achieve effective reuse. While general purpose transformation systems remain mostly research topics, notable results have been achieved in some specific domains: relational systems come with effective query optimizers, some rapid prototyping approaches uses transformations from high-level descriptions down to code, etc.</p>
<h4><a href="http://www.google.com/search?q=Very%20High%20Level%20Languages" target="_blank">Very High Level Languages</a> (<span class="caps">VHLL</span>)</h4>
<p><em>Very High Level Languages</em>, also known as <em>executable specification languages</em>, are languages with very high level of abstraction.  They are somewhat difficult to capture precisely and may lead to software reuse that is very specific to specialized domains. However, I would say that the recent advent of Domain Specific Languages (DSLs) and good support for them in dynamic languages (ruby, python, clojure, &#8230;) can be seen as promoting and helping building VHLLs.</p>
<h4><a href="http://www.google.com/search?q=Software%20schemas" target="_blank">Software schemas</a></h4>
<p>I must confess not being familiar with software schemas. The paper states that <em>software schemas are a formal extension to reusable software components</em> . From what I understand, it seems that we are talking about some kind of formal pseudo code, intended to be instantiated in a particular language. Unfortunately, <a href="http://www.google.com/search?q=software%20schema" target="_blank">a google search does not return relevant results</a>, at the time of writing. I would like to know if they had an impact on current software engineering practices. So if someone knows something about <em>software schemas</em>, just let me know (see the comment form at bottom of this page), and I&#8217;ll be happy to update this section!</p>
<h3>Conclusion</h3>
<p>In this post I&#8217;ve tried to lay some sound foundations for a more practical discussion about software reuse in practice that will take place in a later post. For this, I&#8217;ve mainly reviewed a paper from 1992, namely <em>Software Reuse</em> by Charles W. Krueger. Beyond the specific software reuse techniques discussed, I&#8217;m convinced that the classification and evaluation proposed by the author makes sense. Software reuse means having good abstractions as well as tools to <em>select</em>, <em>specialized</em> and <em>integrate</em> them inside a larger software. Effective reuse is best achieved by techniques that minimize the intellectual effort required by software developers to express an abstract specification as well as converting it to something executable.</p>
<p>See you at the <a href="reuse_in_practice">practical session about reuse</a>!</p>
<h3>References</h3>
<p class="footnote" id="fn1"><a href="#fnr1"><sup>1</sup></a> Charles W. Krueger, <a href="http://www.google.com/search?q=Charles%20W.%20Krueger%20Software%20Reuse" target="_blank"><em>Software Reuse</em></a>, <span class="caps">ACM</span> Computing Surveys, Volume 24 Issue 2, June 1992</p>
<p class="footnote" id="fn2"><a href="#fnr2"><sup>2</sup></a> Peter Naur and Brian Randell, <a href="http://homepages.cs.ncl.ac.uk/brian.randell/NATO/nato1968.PDF"><em>Software engineering: Report of a conference sponsored by the <span class="caps">NATO</span> Science Committee</em></a>, Garmisch, Germany: Scientific Affairs Division, <span class="caps">NATO</span>, October 1968</p>
<p class="footnote" id="fn3"><a href="#fnr3"><sup>3</sup></a> Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides, <a href="http://www.google.com/search?q=Design%20Patterns:%20Elements%20of%20Reusable%20Object-Oriented%20Software" target="_blank">Design Patterns: Elements of Reusable Object-Oriented Software</a>, Addison-Wesley, 1995. <span class="caps">ISBN</span> 0-201-63361-2</p>
<p class="footnote" id="fn4"><a href="#fnr4"><sup>4</sup></a> Erich Gamma and Kent Beck, <a href="http://www.google.com/search?q=Contributing%20to%20Eclipse:%20Principles,%20Patterns,%20and%20Plug-Ins" target="_blank">Contributing to Eclipse: Principles, Patterns, and Plug-Ins</a>, Addison-Wesley, October 2003. <span class="caps">ISBN</span> 0-321-20575-8</p>